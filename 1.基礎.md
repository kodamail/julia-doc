# はじめに

## Julia の紹介・特徴
- 高速
- [多重ディスパッチ](https://ja.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E3%83%87%E3%82%A3%E3%82%B9%E3%83%91%E3%83%83%E3%83%81)
- [動的型付け](https://ja.wikipedia.org/wiki/%E5%8B%95%E7%9A%84%E5%9E%8B%E4%BB%98%E3%81%91)


## インストール
Julia は Windows / Mac / Linux、どれでも簡単にインストールできます。[ダウンロードページ](https://julialang.org/downloads/) から Current stable release（最新安定版）の該当する OS のインストーラを選択します。2022/8/26 時点では v1.7.2 が最新安定版です。例えば64ビット版の Windows であれば、「Windows」の「64-bit (installer)」 をダウンロード・実行すれば特に何もすることはありません。

上記の方法でうまくいかない場合はソースインストールを試みてみましょう。例えば Linux の場合、「Source」の「Tarball with dependencies」をダウンロードし、

```bash
$ tar xvzf julia-1.8.0-full.tar.gz
$ cd julia-1.8.0
$ make
```

とすればコンパイルできます。必要に応じて実行バイナリ（julia）へパスを通せば完了です。なお、ソースインストールは一般ユーザでも可能です。

<!--
jupyterのインストール
-->

## はじめての Julia
```julia``` をダブルクリックやコマンドプロンプトから実行すると、対話的にコマンドを実行する REPL (read-eval-print loop) が立ち上がります。
<!--
テキスト：julia立ち上げ時の様子

Jupyter notebook を使っている場合は、以下のような画面になります。

図：
-->

ここで julia の様々なコマンドを入力することで、処理が実行されます。結果は即座に表示されます。

```Julia
julia> 1 + 2
3
```

なお、行の末尾にセミコロン（;）を付けると結果は即座に表示されないようになります。また、Jupyter notebook では、最後に処理した行の結果が表示されます。

明示的に表示したい場合は ```println()``` を使います。

```Julia
julia> println("Hello Julia!")
Hello Julia!
```

REPL を終了するには ```exit()``` と入力します。

## モード
REPL では処理に応じてモードを切り替えます。

### julia モード
julia を立ち上げた直後のモードは julia モードと呼ばれています。これは julia コマンドを受け付けて処理を行うモードであり、プロンプトには```julia>``` と表示されます。julia 以外のモードにおいてバックスペースを入力すると、julia モードへ戻ることができます。

### ヘルプ（help）モード
julia モードにおいてクエスチョンマーク（?）を入力するとヘルプモードに入ります。ヘルプモードにおいてキーワードを入力すると、関連するドキュメントが表示されます。

もしくは、クエスチョンマークに続いてコマンド名を入力してもOKです。

```Julia
julia> ?transpose()
cos(x)

Compute cosine of x, where x is in radians.

See also [cosd], [cospi], [sincos], [cis].
```

### パッケージ（pkg）モード
julia モードにおいて右角括弧（]）を入力するとパッケージモードに入ります。パッケージをインストールする際に利用します。

```Julia
julia> ]
(@v1.4) pkg> add PyPlot
```

### シェル（shelll）モード
セミコロン（;）を入力するとシステムのシェルのコマンドを受け付けるシェルモードに入ります。Windows では機能しないようです。

## 継続行
Julia で1行のコードを複数行に分ける汎用的な記述方法はありません。但し、ある行が完全な式で終了していない場合、次の行へ継続すると解釈されます。例えば、ある行で括弧が閉じていなければ継続行とみなされます。

## スクリプトファイルの実行
```julia``` コマンドにスクリプト名を渡すと、スクリプトを実行できます。

```bash
$ julia test.jl
```

スクリプトの実行が終了すると julia も終了して呼び出し元に戻ります。実行が終了した後も引き続きREPLで julia を使いたい場合は、オプション ```-i``` をつけて実行します。

```bash
$ julia -i test.jl
```
コマンド名に続いて引数を指定すると、julia から配列変数 ARGS によって参照することができます。

```bash
$ julia -i test.jl aaa bbb
...
julia> ARGS[1]
aaa
```

REPL からスクリプトを実行することもできます。この場合は、```include()``` を利用します。

```Julia
julia> include("test.jl")
```

```include()``` はオーバーヘッドが少ないため、デバッグには重宝します。但し、REPLを立ち上げながら複数回実行すると複数回評価されることになるので注意が必要です。また、引数を与えることはできず、最初に実行した時の引数がそのまま残ります。



# 変数
ある値を指す（格納する）文字列を変数と言います。多くの他言語では事前の型宣言が必要ですが、Julia では型宣言なしにそのまま利用できます。

## 代入と参照
代入演算子（=）を利用すると、右辺で指定した値を左辺の変数へ代入できます。

```Julia
julia> x = 1
1
julia> y = 2.5
2.5
julia> str = "Hello!"
Hello!
```

値の参照は、単に変数名を指定するだけです。

```Julia
julia> y
2.5
```

但し、クオーテーションの中から参照したい場合は、ダラー（$）を変数名の前に付けます。

```Julia
julia> println("y = $y")
y = 2.5
```

## 変数名
Julia の変数名は大文字・小文字の区別があり、アルファベット（A-Z, a-z）、アンダースコア（\_）、又は Unicode の 00A0 以上で開始する必要があります。2文字目以降についてはさらに数値（0-9）、エクスクラメーション（!）、シングルクオーテーション（'）、および他の Unicode 文字を利用することが可能です。但し、if や for といった予約語を変数名として利用することはできません。

アンダースコアのみで構成される変数は、代入のみ可能で参照できない、という少し特殊な性質を持っています。これは、例えば以下のようにダミーで変数を受け取りたい時に役に立ちます（アンダースコアは何個でも構いません）。

```Julia
___, y = size([1 2 3; 4 5 6])
println(y) -> 3
```

変数名として利用可能な Unicode 文字の詳細については、[本家の Allowed Variable Names](https://docs.julialang.org/en/v1/manual/variables/#man-allowed-variable-names) を参考にしてください。

## Julia の予約語
baremodule, begin, break, catch, const, continue, do, else, elseif, end, export, false, finally, for, function, global, if, import, let, local, macro, module, quote, return, struct, true, try, using, while

<!--
## 組み込み変数

-->

## 変数名の慣習
[Julia本家ドキュメント](https://docs.julialang.org/en/v1/manual/variables/#Stylistic-Conventions) によると、変数名には以下に従うことがおすすめされています（強制ではありません）。
- 変数の名前は小文字、語の区切りはアンダースコアを利用する（但し、必要がなければアンダースコアは使わない方がよい）。
- 型、モジュールの名前については大文字で始まり、語の区切りは大文字を利用する。
- 関数、マクロの名前は小文字のみを利用し、アンダースコアは利用しない。
- 関数が引数に書き込む場合、関数名の末尾をエクスクラメーション（!）にする。

<!--
疑問：関数も変数名と同じルールなのか？
-->

## スコープ
変数のスコープとは、変数が参照可能なコードの領域です。Julia のスコープは大域（global）スコープと局所（local）スコープに分類されます。

<!--
## 型
typeof
-->

<!--
TODO:
hard/soft scope
https://docs.julialang.org/en/v1/manual/variables-and-scoping/
-->

<!--
### タプル型
タプル（tuple）は、配列と似た概念です。但し配列と違って、異なる型
-->

