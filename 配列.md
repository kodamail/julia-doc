# 配列

## 生成
配列を生成するにはいくつかの方法があります。まずは関数 `Array()` を用いた最も基本的な方法をみていきましょう。

```Julia
Array{型}(undef, 次元...)
```

例えば倍精度実数で 2x3 の2次元配列 `a` を作成する場合、

```Julia
julia> a = Array{Float64}(undef, 2, 3)
```

と記述します。なお、`a` は初期化されないため、格納されている値は不定です。

```Julia
julia> a
2×3 Matrix{Float64}:
 1.40837e-315  9.10338e-316  1.40837e-315
 1.00098e-315  1.41457e-315  9.10182e-316
```

最初から値を埋めたい場合は `zeros()` や `ones()`、もしくは `fill()` を使いましょう。

```Julia
zeros([型=Float64,] 次元...)
ones([型=Float64,] 次元...)
fill(値, 次元...)
```

`zeros()` は 0 埋め、`ones()` は 1 埋め、`fill()` は任意の値を埋めます。`fill()` については値の型がそのまま配列の型になります。以下は使用例です。

```Julia
julia> a = zeros(Int32, 2, 3)

julia> b = ones(Float64, 2, 2, 2)

julia> c = fill(1, 10)
```

## 配列リテラル
値を羅列することで配列を生成することもできます。以下のように大括弧[]の中にコンマ区切りで値を羅列することで、1次元配列（列ベクトル）を生成することができます。要素の値に応じて型が自動的に決定されます。

```Julia
julia> [1,2,3]
3-element Vector{Int64}:
 1
 2
 3

julia> b=[1.1, 2.2, 3.3]
3-element Vector{Float64}:
 1.1
 2.2
 3.3

julia> println(b)
[1.1, 2.2, 3.3]

julia> eltype(b)
Float64
```

2次元配列（行列）を作成する場合、行の各要素は空白またはダブルセミコロン（;;）で区切り、縦方向はセミコロン（;）もしくは改行で区切ります。

```Julia
julia> [1 2 3; 4 5 6]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6

julia> [1 2 3
        4 5 6]
2×3 Matrix{Int64}:
 1  2  3
 4  5  6
```

以上の応用として、列ベクトルを行方向に並べる形で行列を作成することも可能です。

```Julia
julia> [[1,4] [2,5] [3,6]]
2×3 Matrix{Int64}:
 1  4  7
 2  5  8
```


## 配列のコピー
配列をコピーする場合は `copy()` を利用します。

```Julia
julia> a = copy(b)
```
なお、`=` を用いた代入を用いると、`b` を変更すると `a` にも反映されてしまいます。これは、Julia の関数が共有渡しで引数を渡していることと関係しています。

## 演算子
配列に対して以下の演算子を利用することができます。演算結果は配列で返ります。単なる乗算のように、配列の各要素に対して演算したい場合はブロードキャストを使いましょう。

  * **単項演算子:**

| 演算子 | 名前    | 補足                         |
|:----- |:------ |:-----------------------------|
| `+`   | 単項+   | 特に何もしない                 |
| `-`   | 単項-   | 正負を反転                    |

  * **二項演算子:**

| 演算子 | 名前   | 補足                         |
|:----- |:------ |:----------------------------|
| `+`   | 加算   |                             |
| `-`   | 減算   |                             |
| `*`   | 内積   |                             |
| `/`   |       | `x / y` は `x * inv(y)` と等価  |
| `\`   |       | `x \ y` は `inv(x) * y` と等価|
| `^`   | べき乗 |  `x ^ y` は `x` の `y` 乗    |

  * **比較演算子:**

| 演算子 | 名前   | 意味                        |
|:----- |:------ |:---------------------------|
| `==`  | 等価   |                            |
| `!=`  | 非等価 |                            |

<!--
| `≈`        |                 ||
| `≉`| |
-->


## 配列の結合
`vcat()` は与えられた配列を1次元目方向につなげていきます。特に行列（2次元配列）を縦方向に追加していく場合に便利です。

```Julia
julia> a = [1 2 3 4]
1×4 Matrix{Int64}:
 1  2  3  4

julia> b = [10 20 30 40; 100 200 300 400]
2×4 Matrix{Int64}:
 10   20   30   40
100  200  300  400

julia> c = vcat(a,b)
3×4 Matrix{Int64}:
  1    2    3    4
 10   20   30   40
100  200  300  400
```

行列を横方向に追加したい場合は `hcat()` を使いましょう。これは与えられた配列を2次元目方向につなげていきます。

```Julia
julia> a = [1 2 ; 3 4]
2×2 Matrix{Int64}:
 1  2
 3  4

julia> b = [10 20 30 40 ; 100 200 300 400]
2×4 Matrix{Int64}:
  10   20   30   40
 100  200  300  400

julia> c = hcat(a,b)
2×6 Matrix{Int64}:
 1  2   10   20   30   40
 3  4  100  200  300  400
```

`vcat()`、`hcat()` ともに、引数としていくらでも配列を与えることができます。但し、`vcat()` であればそれぞれの配列の1次元目、`hcat()` であればそれぞれの配列の2次元目を除く各次元の要素数が一致する必要があることに注意が必要です。

以下に配列の結合に関連した関数をまとめておきます。
| 関数名 | 意味                        |
|:----- |:---------------------------|
| [`vcat(a,...)`](https://docs.julialang.org/en/v1/base/arrays/#Base.vcat)       |a, ... の縦結合|
| [`hcat(a,...)`](https://docs.julialang.org/en/v1/base/arrays/#Base.hcat)       |a, ... の横結合|
| [`cat(a,...; dims)`](https://docs.julialang.org/en/v1/base/arrays/#Base.cat)   |a, ... の汎用的な結合|

## その他の配列関数
| 関数名 | 意味                        |
|:----- |:---------------------------|
| `transpose(a)`      |aの転置（aは1-2次元配列）|
| `adjoin(a)` or `a'` |aの随伴行列（aは1-2次元配列）。すなわち、aを転置して各要素について複素共役をとって得られる行列。各要素が実数の場合はaの転置と等価|


# その他
 * [ブロードキャスト](ブロードキャスト.md)


